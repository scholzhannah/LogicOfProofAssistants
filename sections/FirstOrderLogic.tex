\section{First-Order Logic}

\begin{defi}
A (first-order) \alert{language $\fL$} is a triple $(\fF, \fR, a)$ where $\fF$ is a set of function symbols, $\fR$ is a set of relation symbols, $\fF$ and $\fR$ are disjoint and $a \colon \fF \cup \fR \to \bN$ is the arity function.
\end{defi}

\begin{example}
A language for groups $\fL_{\text{Group}}$ has $\fF \coloneq \{\cdot, ^{-1}, 1 \}$, $\fR \coloneq \varnothing$, $a(\cdot) = 2$, $a(^{-1}) = 1$ and $a(1) = 0$.
\end{example}

\begin{defi}
We fix an infinite set of \alert{variables} $\fV \coloneq \{ x_0, x_1, \dots \}$.
\end{defi}

\begin{rem}
We use $x$ for variables, $f$ and $g$ for functions and $R$ and $S$ for relations.
\end{rem}

\begin{defi}
We can define the \alert{terms $T_{\fL}$} in the language $\fL$ using the \alert{Backusâ€“Naur form (BNF)} : 
\begin{equation*}
    s, t \Coloneqq x \mid f(t_1, \dots, t_n)
\end{equation*}
where f is an $n$-ary function symbol.
\end{defi}

\begin{defi}
Formally, we define the \alert{terms $T_{\fL}$} in the language $\fL$ in the following way. We define the set of \alert{symbols} $S \coloneq \fF \cupdot \fV \cupdot \{"(", ")", "," \}$ and the set of finite sequences of symbols $S^*$. 
Let $\fC$ be defined as: 
\begin{enumerate}
    \item for each variable $x \in \fV$ there is a nullary constructor $c_x \coloneq x$
    \item for each $n$-ary function symbol $f$ there is an $n$-ary constructor $c_f \colon (S^*)^n \to S^*$, $c_f(t_1, \dots, t_n) \coloneq f"("t_1"," \dots "," t_n ")"$
\end{enumerate}
Then $T_{\fL} \subseteq S^*$ is the set generated by $\fC$.
\end{defi}

\begin{example}
    \hfill
    \begin{enumerate}
        \item $"("")"","f$ is in $S^*$ but not in $T_{\fL}$. 
        \item If $f$ is binary then $f"("x_0 "," x_1 ")"$ is in $T_{\fL}$.
    \end{enumerate}
\end{example}

\begin{rem}
Technically, the brackets and commas are not necessary. 
They are however necessary when you use infix notation. 
(For example the meaning of $a \cdot b + c$ is unclear.)
\end{rem}

\begin{defi}
First-order \alert{formulas $\Phi_{\fL}$} are specified by
\begin{equation*}
    \varphi, \psi \Coloneqq \bot \mid s = t \mid R(t_1, \dots t_n) \mid (\varphi \wedge \psi) \mid (\varphi \lor \psi) \mid (\varphi \to \psi) \mid (\forall x. \varphi) \mid (\exists x. \varphi)
\end{equation*}
where $\fR$ is an $n$-ary relation symbol and $t_1, \dots, t_n \in T_{\fL}$.
\end{defi}

\begin{rem}
In classical logic one could omit the rules $(\varphi \wedge \psi)$ and $(\varphi \lor \psi)$ (as they can be defined using the other rules). 
They are however necessary for constructive logic.
\end{rem}

\begin{rem}
We can define other connectives: 
\begin{enumerate}
    \item $\neg \varphi \coloneq (\varphi \to \bot)$
    \item $\varphi \leftrightarrow \psi \coloneq ((\varphi \to \psi) \wedge (\psi \to \varphi))$
\end{enumerate}
\end{rem}

\begin{rem}
When writing formulas we omit some parentheses: 
\begin{enumerate}
    \item $\varphi \to \psi \to \theta$ means $\varphi \to (\psi \to \theta)$
    \item $\forall x. \varphi \to \psi$ means $\forall x. (\varphi \to \psi)$
\end{enumerate}
\end{rem}

\begin{rem}
We want $\forall x. x = x$ and $\forall y. y = y$ to mean the same thing. 
Options to achieve this are: 
\begin{enumerate}
    \item Define $(\forall x. x = x) \equiv_{\alpha} (\forall y. y = y)$ to be \alert{$\alpha$-equivalent}. And then define the set of formulas to be $\Phi_{\fL} / \equiv_{\alpha}$.
    \item We could not use variable names for bound variables and use \alert{de Bruijn indices} instead.
\end{enumerate}
\end{rem}