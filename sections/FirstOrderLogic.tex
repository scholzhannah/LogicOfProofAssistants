\section{First-Order Logic}

\begin{boxdef}
\begin{defi}
A (first-order) \alert{language $\fL$} is a triple $(\fF, \fR, a)$ where $\fF$ is a set of function symbols, $\fR$ is a set of relation symbols, $\fF$ and $\fR$ are disjoint and $a \colon \fF \cup \fR \to \bN$ is the arity function.
\end{defi}
\end{boxdef}

\begin{example}
A language for groups $\fL_{\text{Group}}$ has $\fF \coloneq \{\cdot, ^{-1}, 1 \}$, $\fR \coloneq \varnothing$, $a(\cdot) = 2$, $a(^{-1}) = 1$ and $a(1) = 0$.
\end{example}

\begin{boxdef}
\begin{defi}
We fix an infinite set of \alert{variables} $\fV \coloneq \{ x_0, x_1, \dots \}$.
\end{defi}
\end{boxdef}

\begin{rem}
We use $x$ for variables, $f$ and $g$ for functions and $R$ and $S$ for relations.
\end{rem}

\begin{boxdef}
\begin{defi}
We can define the \alert{terms $T_{\fL}$} in the language $\fL$ using the \alert{Backusâ€“Naur form (BNF)} : 
\begin{equation*}
    s, t \Coloneqq x \mid f(t_1, \dots, t_n)
\end{equation*}
where $f$ is an $n$-ary function symbol.
\end{defi}
\end{boxdef}

\begin{boxdef}
\begin{defi}
Formally, we define the \alert{terms $T_{\fL}$} in the language $\fL$ in the following way. We define the set of \alert{symbols} $S \coloneq \fF \cupdot \fV \cupdot \{\menquote{(}, \menquote{)}, \menquote{,} \}$ and the set of finite sequences of symbols $S^*$. 
Let $\fC$ be defined as: 
\begin{enumerate}
    \item for each variable $x \in \fV$ there is a nullary constructor $c_x \coloneq x$
    \item for each $n$-ary function symbol $f$ there is an $n$-ary constructor $c_f \colon (S^*)^n \to S^*$, $c_f(t_1, \dots, t_n) \coloneq f\menquote{(}t_1\menquote{,} \dots \menquote{,} t_n \menquote{)}$
\end{enumerate}
Then $T_{\fL} \subseteq S^*$ is the set generated by $\fC$.
\end{defi}
\end{boxdef}

\begin{example}
    \hfill
    \begin{enumerate}
        \item $\menquote{(}\menquote{)}\menquote{,}f$ is in $S^*$ but not in $T_{\fL}$. 
        \item If $f$ is binary then $f\menquote{(}x_0 \menquote{,} x_1 \menquote{)}$ is in $T_{\fL}$.
    \end{enumerate}
\end{example}

\begin{rem}
Technically, the brackets and commas are not necessary. 
They are however necessary when you use infix notation. 
(For example the meaning of $a \cdot b + c$ is unclear.)
\end{rem}

\begin{boxdef}
\begin{defi}
First-order \alert{formulas $\Phi_{\fL}$} are specified by
\begin{equation*}
    \varphi, \psi \Coloneqq \bot \mid s = t \mid R(t_1, \dots t_n) \mid (\varphi \wedge \psi) \mid (\varphi \lor \psi) \mid (\varphi \to \psi) \mid (\forall x. \varphi) \mid (\exists x. \varphi)
\end{equation*}
where $\fR$ is an $n$-ary relation symbol and $t_1, \dots, t_n \in T_{\fL}$.
\end{defi}
\end{boxdef}

\begin{rem}
In classical logic one could omit the rules $(\varphi \wedge \psi)$ and $(\varphi \lor \psi)$ (as they can be defined using the other rules). 
They are however necessary for constructive logic.
\end{rem}

\begin{rem}
We can define other connectives: 
\begin{enumerate}
    \item $\neg \varphi \coloneq (\varphi \to \bot)$
    \item $\varphi \leftrightarrow \psi \coloneq ((\varphi \to \psi) \wedge (\psi \to \varphi))$
\end{enumerate}
\end{rem}

\begin{rem}
When writing formulas we omit some parentheses: 
\begin{enumerate}
    \item $\varphi \to \psi \to \theta$ means $\varphi \to (\psi \to \theta)$
    \item $\forall x. \varphi \to \psi$ means $\forall x. (\varphi \to \psi)$
\end{enumerate}
\end{rem}

\begin{rem}
We want $\forall x. x = x$ and $\forall y. y = y$ to mean the same thing. 
Options to achieve this are: 
\begin{enumerate}
    \item Define $(\forall x. x = x) \aeq (\forall y. y = y)$ to be \alert{$\alpha$-equivalent}. And then define the set of formulas to be $\Phi_{\fL} / \aeq$.
    \item We could not use variable names for bound variables and use \alert{de Bruijn indices} instead.
\end{enumerate}
\end{rem}

\begin{rem}
    $\forall x. x = y$ has \alert{bound variables} $\{x\}$ and \alert{free variables} $\{y\}$. For a formula $\varphi$ or a term $t$ we also write \alert{$\fv{\varphi}$} and \alert{$\fv{t}$} for the set of free variables in $\varphi$ and $t$.
\end{rem}

\begin{boxdef}
\begin{defi}
    A \alert{sentence} is a formula without free variables.
\end{defi}
\end{boxdef}

\begin{boxdef}
\begin{defi}
    \alert{Substitution $s[t/x]$} of $x$ by $t$ in a term $s$ is defined recursively by 
    \begin{enumerate}
        \item {$ y[t/x] \coloneq 
                \begin{cases}
                    t & \text{if } y = x \\
                    y & \text{otherwise}
                \end{cases}$}
        \item $f(s_1, \dotsm s_n)[t/x] \coloneq f(s_1[t/x], \dots, s_n[t/x])$
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{example}
    Defining substitution in formulas is a little bit harder as we need to avoid \alert{variable capture}:
    $(\exists x. x \leq z)[(x + 1)/z]$ should not be $\exists x. x \leq x + 1$ but $\exists y. y \leq x + 1$.
\end{example}

\begin{boxdef}
\begin{defi}
    For a formula $\varphi$ \alert{substitution $\varphi[t/x]$} is defined as: 
    \begin{enumerate}
        \item $s = s'[t/x] \coloneq s[t/x] = s'[t/x]$
        \item $R(t_1, \dots, t_n)[t/x] \coloneq R(t_1[t/x], \dots, t_n[t(x)])$
        \item $(\varphi \lor \psi)[t/x] \coloneq \varphi[t/x] \lor \psi[t/x]$
        \item $(\varphi \wedge \psi)[t/x] \coloneq \varphi[t/x] \wedge \psi[t/x]$
        \item $(\varphi \to \psi)[t/x] \coloneq \varphi[t/x] \to \psi[t/x]$
        \item {$ (\forall y. \varphi) \coloneq 
            \begin{cases}
                \forall y. \varphi & \text{if } y = x \\
                \forall z. \varphi[z/y][t/x] & \text{otherwise}
            \end{cases}$}
        \item {$ (\exists y. \varphi) \coloneq 
        \begin{cases}
            \exists y. \varphi & \text{if } y = x \\
            \exists z. \varphi[z/y][t/x] & \text{otherwise}
        \end{cases}$}
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{boxdef}
\begin{defi}
    \alert{$\alpha$-equivalence} is the \alert{congruence closure} of 
    \begin{enumerate}
        \item $(\forall x. \varphi) \aeq (\forall y. \varphi[y/x])$
        \item $(\exists x. \varphi) \aeq (\exists y. \varphi[y/x])$
    \end{enumerate}
    i.e. it is the smallest equivalence relation containing these two rules and respecting the connectives: 
    \begin{enumerate}
        \item $(\varphi_1 \wedge \varphi_2) \aeq (\psi_1 \wedge \psi_2)$ for $\varphi_1 \aeq \psi_1$ and $\varphi_2 \aeq \psi_2$
        \item $(\varphi_1 \lor \varphi_2) \aeq (\psi_1 \lor \psi_2)$ for $\varphi_1 \aeq \psi_1$ and $\varphi_2 \aeq \psi_2$
        \item $(\varphi_1 \to \varphi_2) \aeq (\psi_1 \to \psi_2)$ for $\varphi_1 \aeq \psi_1$ and $\varphi_2 \aeq \psi_2$
        \item $(\forall x. \varphi) \aeq (\forall x. \psi)$ if $\varphi \aeq \psi$
        \item $(\exists x. \varphi) \aeq (\exists x. \psi)$ if $\varphi \aeq \psi$
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{rem}
    We will treat $\alpha$-equivalence as an equivalence relation. 
    You could also define the formulas as $\Phi_{\fL} / \aeq$ and thus treat $\alpha$-equivalence as equality.
\end{rem}

\subsection{Provability}

\begin{boxdef}
\begin{defi}
    Let $\Gamma$ be a set of formulas and $\varphi$ a formula.
    Then $\alert{\Gamma \vdash \varphi}$ (read : ``$\Gamma$ proves $\varphi$'') is defined inductively by 
    \begin{enumerate}
        \item {
            \AxiomC{}
            \UnaryInfC{$\Gamma, \varphi \vdash \varphi$}
            \DisplayProof
            (assumption rule)}
        \item {
            \AxiomC{$\Gamma \vdash \varphi$}
            \AxiomC{$\Gamma \vdash \psi$}
            \BinaryInfC{$\Gamma \vdash \varphi \wedge \psi$}
            \DisplayProof
            ($\wedge$-introduction)}
        \item {
            \AxiomC{$\Gamma \vdash \varphi_1 \wedge \varphi_2$}
            \UnaryInfC{$\Gamma \vdash \varphi_i$}
            \DisplayProof
            for $i = 1, 2$ 
            ($\wedge$-elimination)}
        \item {
            \AxiomC{$\Gamma \vdash \varphi_i$}
            \UnaryInfC{$\Gamma \vdash \varphi_1 \lor \varphi_2$}
            \DisplayProof
            for $i = 1, 2$
            ($\lor$-introduction)}
        \item{
            \AxiomC{$\Gamma \vdash \varphi \lor \psi$}
            \AxiomC{$\Gamma, \varphi \vdash \theta$}
            \AxiomC{$\Gamma, \psi \vdash \theta$}
            \TrinaryInfC{$\Gamma \vdash \theta$}
            \DisplayProof
            ($\lor$-elimination)}
        \item{
            \AxiomC{$\Gamma, \varphi \vdash \psi$}
            \UnaryInfC{$\Gamma \vdash \varphi \to \psi$}
            \DisplayProof
            ($\to$-introduction)}
        \item {
            \AxiomC{$\Gamma \vdash \varphi \to \psi$}
            \AxiomC{$\Gamma \vdash \varphi$}
            \BinaryInfC{$\Gamma \vdash \psi$}
            \DisplayProof
            ($\to$-elimination)}
        \item {
            \AxiomC{$\Gamma, \neg \varphi \vdash \bot$}
            \UnaryInfC{$\Gamma \vdash \varphi$}
            \DisplayProof
            (proof by contradiction)}
        \item {
            \AxiomC{$\Gamma \vdash \varphi$}
            \UnaryInfC{$\Gamma \vdash \forall x. \varphi$}
            \DisplayProof
            for $x \notin \fv{\Gamma}$
            ($\forall$-introduction)}
        \item {
            \AxiomC{$\Gamma \vdash \forall x. \varphi$}
            \UnaryInfC{$\Gamma \vdash \varphi[t/x]$}
            \DisplayProof
            ($\forall$-elimination)}
        \item{
            \AxiomC{$\Gamma \vdash \varphi[t/x]$}
            \UnaryInfC{$\Gamma \vdash \exists x. \varphi$}
            \DisplayProof
            ($\exists$-introduction)}
        \item {
            \AxiomC{$\Gamma \vdash \exists x. \varphi$}
            \AxiomC{$\Gamma, \varphi \vdash \psi$}
            \BinaryInfC{$\Gamma \vdash \psi$}
            \DisplayProof
            for $x \in \fv{\Gamma, \psi}$
            ($\exists$-elimination)}
        \item {
            \AxiomC{}
            \UnaryInfC{$\Gamma \vdash t = t$}
            \DisplayProof
            ($=$-introduction)}
        \item {
            \AxiomC{$\Gamma \vdash s = t$}
            \AxiomC{$\Gamma \vdash \varphi[t/x]$}
            \BinaryInfC{$\Gamma \vdash \varphi[s/x]$}
            \DisplayProof
            ($=$-elimination)}
        \item {
            \AxiomC{$\Gamma \vdash \varphi$}
            \UnaryInfC{$\Gamma \vdash \psi$}
            \DisplayProof
            for $\varphi \aeq \psi$
            ($\alpha$-equivalence)}
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{rem}
    Read ``\AxiomC{A} \UnaryInfC{B} \DisplayProof'' as: ``Under the assumptions A we can prove B''.
    With ``$\Gamma, \varphi$'' we really mean $\Gamma \cup \{\varphi\}$.
\end{rem}

\begin{example}
    If $\varphi$ and $\psi$ are formulas then we can show $\vdash (\varphi \wedge \psi) \to (\psi \wedge \varphi)$ using the following \alert{proof tree} : 
    \begin{prooftree}
        \AxiomC{}
        \RightLabel{Assump.}
        \UnaryInfC{$\varphi \wedge \psi \vdash \varphi \wedge \psi$}
        \RightLabel{$\wedge$-elim.}
        \UnaryInfC{$\varphi \wedge \psi \vdash \psi$}
        \AxiomC{}
        \RightLabel{Assump.}
        \UnaryInfC{$\varphi \wedge \psi \vdash \varphi \wedge \psi$}
        \RightLabel{$\wedge$-elim.}
        \UnaryInfC{$\varphi \wedge \psi \vdash \varphi$}
        \RightLabel{$\wedge$-intro.}
        \BinaryInfC{$\varphi \wedge \psi \vdash \psi \wedge \varphi$}
        \RightLabel{$\to$-intro.}
        \UnaryInfC{$\vdash (\varphi \wedge \psi) \to (\psi \wedge \varphi)$}
    \end{prooftree}
\end{example}

\subsection{Semantics}

\begin{boxdef}
\begin{defi}
    An \alert{$\fL$-structure} $\fM$ consists of 
    \begin{enumerate}
        \item a non-empty set $\abs{\fM}$
        \item for any $n$-ary function symbol $f$ a function $f_{\fM} \colon \abs{\fM}^n \to \abs{\fM}$
        \item for any $n$-ary relation symbol $R$ a set $R_{\fM} \subseteq \abs{\fM}^n$
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{boxdef}
\begin{defi}
    If $t$ is an $\fL$-term and $\sigma \colon \fV \to \abs{\fM}$ we define \alert{$\interpret{t}_{\fM, \sigma}$} as: 
    \begin{enumerate}
        \item $\interpret{x}_{\fM, \sigma} \coloneq \sigma(x)$
        \item $\interpret{f(t_1, \dots, t_n)}_{\fM, \sigma} \coloneq f_{\fM}(\interpret{t_1}_{\fM, \sigma}, \dots, \interpret{t_n}_{\fM, \sigma})$
    \end{enumerate}
    For formulas we define \alert{$\fM \smodels \varphi$} holds as 
    \begin{enumerate}
        \item $\fM \smodels R(t_1, \dots, t_n)$ iff $R_{\fM}(\interpret{t_1}_{\fM, \sigma}, \dots, \interpret{t_n}_{\fM, \sigma})$
        \item $\fM \smodels \bot$ never holds
        \item $\fM \smodels s = t$ iff $\interpret{s}_{\fM, \sigma} = \interpret{t}_{\fM, \sigma}$
        \item $\fM \smodels \varphi \wedge \psi$ iff $\fM \smodels \varphi$ and $\fM \smodels \psi$
        \item $\fM \smodels \varphi \lor \psi$ iff $\fM \smodels \varphi$ or $\fM \smodels \psi$
        \item $\fM \smodels \varphi \to \psi$ iff $\fM \smodels \varphi$ implies $\fM \smodels \psi$
        \item $\fM \smodels \forall x. \varphi$ iff for all $a \in \abs{\fM}$ we know that $\fM \operatorname{\models_{\sigma, x \mapsto a}} \varphi$ where 
        
        $(\sigma, x \mapsto a)(y) \coloneq
        \begin{cases}
            a & y = x \\
            \sigma(y) & \text{otherwise}
        \end{cases}$
        \item $\fM \smodels \exists x. \varphi$ iff there is $a \in \abs{\fM}$ such that $\fM \operatorname{\models_{\sigma, x \mapsto a}} \varphi$
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{rem}
    We write \alert{$\varphi(\vect{x})$} to mean that $\fv{\varphi} \subseteq \vect{x}$ and \alert{$\varphi(\vect{t})$} for $\varphi[\vect{t}/\vect{x}]$.
\end{rem}

\begin{rem}
    $\interpret{t}_{\fM, \sigma}$ and $\fM \smodels \varphi$ only depend on the values $\sigma(x)$ where $x \in \fv{t}$ and $x \in \fv{\varphi}$ respectively.
    If $\varphi$ is a sentence then $\fM \smodels \varphi$ does not depend on $\sigma$ and is denoted \alert{$\fM \models \varphi$} (read: ``$\fM$ realizes $\varphi$'').
\end{rem}

\begin{boxdef}
\begin{defi}
    If $\Gamma$ is a set of formulas and $\varphi$ is a formula then \alert{$\Gamma \models \varphi$} means that for any $\fL$-structure $\fM$ and assignment $\sigma \colon \fV \to \abs{\fM}$ such that $\fM \smodels \psi$ for all $\psi \in \Gamma$ we have $\fM \smodels \varphi$.
\end{defi}
\end{boxdef}

\begin{boxthe}
\begin{thm}[Soundness theorem]
    If $\Gamma \vdash \varphi$ then $\Gamma \models \varphi$.
\end{thm}
\end{boxthe}

\begin{boxthe}
\begin{thm}[Completeness theorem]
    If $\Gamma \models \varphi$ then $\Gamma \vdash \varphi$.
\end{thm}
\end{boxthe}

\begin{boxthe}
\begin{thm}[Compactness theorem]
    If $\Gamma \models \varphi$ then for some finite $\Gamma' \subseteq \Gamma$ we have $\Gamma' \models \varphi$.
\end{thm}
\end{boxthe}

\subsection{Definite descriptions}

\begin{boxdef}
\begin{defi}
    $\alert{\exists!}x. \varphi(x, \vect{z}) \coloneq \exists x. (\varphi(x, \vect{z}) \wedge \forall y. \varphi(y, \vect{z}) \to y = x)$.
\end{defi}
\end{boxdef}

\begin{boxdef}
\begin{defi}
    Suppose $\Gamma$ is a set of $\fL$-sentences, $\Gamma'$ a set of $\fL'$-sentences and $\fL \subseteq \fL'$.
    Then \alert{$\Gamma'$ is conservative over $\Gamma$} if $\Gamma \subseteq \Gamma'$ and for all $\fL$-formulas $\psi$ such that $\Gamma' \vdash \psi$ we have $\Gamma \vdash \psi$. 
\end{defi}
\end{boxdef}

\begin{boxthe}
\begin{thm}
    Suppose that $\Gamma \vdash \forall \vect{x}. \exists! \varphi(\vect{x}, y)$ and that $f$ is a fresh function symbol (i.e. not among the function symbols of $\fL$) then $\Gamma \cup \{\forall \vect{x}. \varphi(\vect{x}, f(\vect{x}))\}$ is conservative over $\Gamma$.
\end{thm}
\end{boxthe}

\begin{boxdef}
\begin{defi}[Axioms of ZFC]
    \alert{$\fL_{ZFC}$} has no function symbol and one binary relation ``$\in$''. 
    The axioms of ZFC are
    \begin{enumerate}
        \item Extensionality : $\forall x \forall y. (\forall z. z \in x \leftrightarrow z \in y) \to x = y$
        \item Pairing: $\forall x \forall y \exists z \forall w. w \in z \leftrightarrow w = x \lor w = y$ (``$z = \{x,y\}$'')
        
        This allows us to define $\{x\} \coloneq \{x, x\}$.
        \item Union: $\forall x \exists y \forall z. z \in y \leftrightarrow \exists w. (w \in x \wedge z \in w)$ (``$y = \bigcup x$'')
        
        This allows us to define $x \cup y \coloneq \bigcup \{x, y\}$.
        \item Power set: $\forall x \exists y \forall z. z \in y \leftrightarrow w \in x$ (``$y = \pow{x}$'')
        \item Separation (axiom schema): for any formula $\varphi(\vect{x}, y)$ we have $\forall \vect{x} \forall y \exists z \forall w. w \in z \leftrightarrow (w \in y \wedge \varphi(\vect{x}, w))$ (``$z = \{ w \in y \mid \varphi(\vect{x}, w)\}$'')
        \item Infinity: $\exists x. \varnothing \in x \wedge \forall y. y \in x \to y \cup \{y\} \in x$ where $\varnothing \coloneq \{w \in y \mid \bot\}$
        \item Foundation: $\forall x. (\exists y. y \in x) \to \exists y. y \in x \wedge \forall z. z \in x \to z \notin y$ (``Every set $x$ contains an element $y$ disjoint from $x$'')
        \item Replacement (axiom schema): For any formula $\varphi(z, w, \vect{y})$ we have $\forall x \forall \vect{y} (\forall z. z \in x \to \exists! w \varphi(z, w, \vect{y})) \to \exists u \forall w. w \in u \leftrightarrow \exists z. z \in x \wedge \varphi(z, w, \vect{y})$ (``If $\varphi$ is a function with domain $x$ then the image of $\varphi$ is a set.'')
        \item Choice: $\forall x. \varnothing \notin x \to \exists f. f \in (x \to \bigcup x) \wedge \forall y. y \in x  \to f(y) \in y$
        
        where we define $(x , y) \coloneq \{\{x\}, \{x, y\}\}$, 
        
        $A \times B \coloneq \{ z \in \pow{\pow{A \cup B}} \mid \exists x \in A \exists y \in B. z = (x, y)\}$, 
        
        $(A \to B) \coloneq \{f \in \pow{A \times B} \mid \forall x \in A \exists! y. (x, y) \in f \}$ and
        
        $f(x) \coloneq 
        \begin{cases}
            y & \text{if } (x, y) \in f \\
            \varnothing & \text{if no such $y$ exists} \\
        \end{cases}$
    \end{enumerate}
\end{defi}
\end{boxdef}

\begin{rem}
    The existence of at least one set is provable and therefore the empty set also exists. 
    Nonetheless, the existence of the empty set is often added as an axiom.
\end{rem}